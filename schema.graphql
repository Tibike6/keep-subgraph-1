type TBTCDepositToken @entity {
  id: ID!
  deposit: Deposit
  tokenID: BigInt!
  owner: Bytes!
  mintedAt: BigInt!
  minter: Bytes!
}

# type FeeRebateToken @entity {
#   id: ID!
#   name: String!
#   symbol: String!
#   address: Bytes!
# }

# This logs everything about the system, but no tBTC or KEEP transfers.
#interface LogEntry @entity {
#  id: ID!
#  timestamp: BigInt!
#}
#
#interface LogEntryDeposit {
#  deposit: Deposit!
#}
#
#type LogEntryTDTTransfer implements LogEntry & LogEntryDeposit @entity {
#  id: ID!
#  timestamp: BigInt!
#
#  token: TBTCDepositToken!
#  deposit: Deposit!
#}

type LogEntry @entity {
  id: ID!
  transactionHash: String!
  timestamp: BigInt!

  deposit: Deposit!
  message: String!
}

# from https://github.com/keep-network/tbtc/blob/master/solidity/contracts/deposit/DepositUtils.sol
type Deposit @entity {
  id: ID!
  tbtcSystem: Bytes! # address of the system contract
  contractAddress: Bytes!
  tdtToken: TBTCDepositToken!
  currentState: DepositState
  createdAt: BigInt

  # SET DURING CONSTRUCTION
  keepAddress: Bytes # The address of our keep contract
  lotSizeSatoshis: BigInt
  initialCollateralizedPercent: Int
  collateralizationPercent: Int
  undercollateralizedThresholdPercent: Int
  severelyUndercollateralizedThresholdPercent: Int
  signerFee: BigInt
  utxoSize: BigInt
  endOfTerm: BigInt
  auctionValue: BigInt
  bondedECDSAKeep: BondedECDSAKeep

  # SET ON FRAUD
  depositLiquidation: DepositLiquidation

  # INITIALLY WRITTEN BY REDEMPTION FLOW
  depositRedemption: DepositRedemption
}

enum DepositState {
  # DOES NOT EXIST YET
  START

  # FUNDING FLOW
  AWAITING_SIGNER_SETUP
  AWAITING_BTC_FUNDING_PROOF

  # FAILED SETUP
  FAILED_SETUP

  # ACTIVE
  ACTIVE # includes courtesy call
  # REDEMPTION FLOW
  AWAITING_WITHDRAWAL_SIGNATURE
  AWAITING_WITHDRAWAL_PROOF
  REDEEMED

  # SIGNER LIQUIDATION FLOW
  COURTESY_CALL
  FRAUD_LIQUIDATION_IN_PROGRESS
  LIQUIDATION_IN_PROGRESS
  LIQUIDATED
}

type DepositLiquidation @entity {
  id: ID!
  deposit: Deposit!
  initiateTxhash: Bytes
  courtesyCallTxhash: Bytes
  liquidationInitiated: BigInt # Timestamp of when liquidation starts
  courtesyCallInitiated: BigInt # When the courtesy call is issued
  isLiquidated: Boolean!
  liquidatedAt: BigInt
  liquidationInitiator: Bytes
  wasFraud: Boolean
}

type DepositRedemption @entity {
  id: ID!
  deposit: Deposit!
  redeemerOutputScript: Bytes # The redeemer output script
  requestedFee: BigInt # the initial fee as requested
  latestRedemptionFee: BigInt # the fee currently required by a redemption transaction
  withdrawalRequestAt: BigInt # the most recent withdrawal request timestamp
  redeemedAt: BigInt
  lastRequestedDigest: Bytes # the digest most recently requested for signing
  outpoint: Bytes
  utxoSize: BigInt
  txid: Bytes
}

type KeepMember @entity {
  id: ID!
  address: Bytes!
  keeps: [BondedECDSAKeep!] @derivedFrom(field: "members")
}

type BondedECDSAKeep @entity {
  id: ID!
  keepAddress: Bytes!
  deposit: Deposit!
  totalBondAmount: BigInt
  publicKey: Bytes
  status: BondedECDSAKeepStatus
  honestThreshold: Int
  members: [KeepMember]!
}

enum BondedECDSAKeepStatus {
  ACTIVE
  CLOSED
  TERMINATED
}

type GovernanceLogEntry @entity {
  id: ID!
  timestamp: BigInt!
  submitter: Bytes!
  block: BigInt!
  transactionHash: String!
  isRequest: Boolean!
  change: GovernanceChange
}

enum GovernanceChangeType {
  LOT_SIZES,
  SIGNER_FEE_DIVISOR,
  KEEP_FACTORIES,
  COLLATERALIZATION_THRESHOLDS,
  ETH_BTC_PRICE_FEED_ADDITION
}

type GovernanceChange @entity {
  id: ID!
  type: GovernanceChangeType!
  requestedAt: BigInt!
  takesEffectAfter: BigInt!
  requestBlock: BigInt!
  requestTransactionHash: String!
  finalizeBlock: BigInt
  finalizeTransactionHash: String,

  # A copy of the governance type, but all fields are optional. It might be preferable to use interfaces
  # and separate subtypes for each log change kind, but this spams the type list of the graph too much,
  # and we have no ability for any type to be non-root.
  newLotSizes: [BigInt!]
  newSignerFeeDivisor: Int,
  newFactorySelector: Bytes
  newFullyBakedFactory: Bytes
  newKeepStakedFactory: Bytes,
  newPriceFeed: Bytes,
  newInitialCollateralizedPercent: Int,
  newSeverelyUndercollateralizedThresholdPercent: Int,
  newUndercollateralizedThresholdPercent: Int,
}

type Governance @entity {
  id: ID!

  newDepositsAllowed: Boolean!

  signerFeeDivisor: Int,
  pendingSignerFeeDivisorChange: GovernanceChange,

  lotSizes: [BigInt!]!
  pendingLotSizeChange: GovernanceChange

  factorySelector: Bytes!
  fullyBakedFactory: Bytes!
  keepStakedFactory: Bytes!
  pendingFactoriesChange: GovernanceChange

  priceFeeds: [Bytes!]!
  pendingPriceFeedAddition: GovernanceChange,

  initialCollateralizedPercent: Int!,
  severelyUndercollateralizedThresholdPercent: Int!,
  undercollateralizedThresholdPercent: Int!,
  pendingCollateralizationThresholdsChange: GovernanceChange,
}