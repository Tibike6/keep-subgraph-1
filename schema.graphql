type TBTCDepositToken @entity {
  id: ID!
  deposit: Deposit
  tokenID: BigInt!
  owner: Bytes!
  mintedAt: BigInt!
  minter: Bytes!
}

# A generic event log entry
interface Event {
  id: ID!
  submitter: Bytes!
  transactionHash: String!
  timestamp: BigInt!

  # Set if this affects a deposit
  deposit: Deposit
}

type CreatedEvent implements Event @entity {
  id: ID!
  submitter: Bytes!
  transactionHash: String!
  timestamp: BigInt!
  deposit: Deposit
}

type FundedEvent implements Event @entity {
  id: ID!
  submitter: Bytes!
  transactionHash: String!
  timestamp: BigInt!
  deposit: Deposit

  tx: Bytes!
}

type RegisteredPubKeyEvent implements Event @entity {
  id: ID!
  submitter: Bytes!
  transactionHash: String!
  timestamp: BigInt!
  deposit: Deposit

  signingGroupPubkeyX: Bytes!
  signingGroupPubkeyY: Bytes!
}

type RedeemedEvent implements Event @entity {
  id: ID!
  submitter: Bytes!
  transactionHash: String!
  timestamp: BigInt!
  deposit: Deposit

  tx: Bytes!
}

type GotRedemptionSignatureEvent implements Event @entity {
  id: ID!
  submitter: Bytes!
  transactionHash: String!
  timestamp: BigInt!
  deposit: Deposit
}

type RedemptionRequestedEvent implements Event @entity {
  id: ID!
  submitter: Bytes!
  transactionHash: String!
  timestamp: BigInt!
  deposit: Deposit

  redeemerOutputScript: Bytes!
  requestedFee: BigInt!
  utxoValue: BigInt!
  utxoOutpoint: Bytes!
  redeemer: Bytes!
  sigHashDigest: Bytes!
}

enum SetupFailedReason {
  # Both of those cases are handled the same in the contract, but we want to differentiate
  # between one of the signers failing to publish a key (PublicKeyPublished is never raised)
  # and the depositor simply abandoning the process and not "picking up the key" (calling
  # `retrieveSignerPubkey()`) - which is really more comparible with the depositor failing
  # to fund the deposit.
  SIGNER_SETUP_FAILED,
  SIGNER_SETUP_FAILED_DEPOSITOR,

  FUNDING_TIMEOUT,
  FUNDING_ECDSA_FRAUD
}

type SetupFailedEvent implements Event @entity {
  id: ID!
  submitter: Bytes!
  transactionHash: String!
  timestamp: BigInt!
  deposit: Deposit

  "The reason for the failure, based on which contract call caused the failure state to be entered."
  reason: SetupFailedReason
}

type LiquidatedEvent implements Event @entity {
  id: ID!
  submitter: Bytes!
  transactionHash: String!
  timestamp: BigInt!
  deposit: Deposit
}

type CourtesyCalledEvent implements Event @entity {
  id: ID!
  submitter: Bytes!
  transactionHash: String!
  timestamp: BigInt!
  deposit: Deposit
}

type StartedLiquidationEvent implements Event @entity {
  id: ID!
  submitter: Bytes!
  transactionHash: String!
  timestamp: BigInt!
  deposit: Deposit

  "The cause of this deposit going into liquidation"
  cause: LiquidationCause
}

# from https://github.com/keep-network/tbtc/blob/master/solidity/contracts/deposit/DepositUtils.sol
type Deposit @entity {
  id: ID!
  tbtcSystem: Bytes! # address of the system contract
  contractAddress: Bytes!
  tdtToken: TBTCDepositToken!
  currentState: DepositState
  createdAt: BigInt
  updatedAt: BigInt

  # owner is the owner of the TDT token, will match tdtToken.owner (shortcut). we have this mostly because
  # it makes our code easier!
  owner: Bytes!

  "The address which created the deposit initially. In contrast to the owner, this cannot change."
  creator: Bytes!

  keepAddress: Bytes
  lotSizeSatoshis: BigInt
  initialCollateralizedPercent: Int
  undercollateralizedThresholdPercent: Int
  severelyUndercollateralizedThresholdPercent: Int
  signerFee: BigInt
  utxoSize: BigInt
  endOfTerm: BigInt
  bondedECDSAKeep: BondedECDSAKeep

  depositLiquidation: DepositLiquidation
  depositRedemption: DepositRedemption
  depositSetup: DepositSetup @derivedFrom(field: "deposit")

  # Because TheGraph does not support complex filters (and/or), we pre-calculate some useful ones here.
  filter_liquidationLikeState: Boolean!,
  filter_activeLikeState: Boolean!,
  filter_unmintedTDT: Boolean!,
  # will be the endOfTerm, or, if the deposit is already reeemable before that, will be maxInt. If not redeemable because closed, will be 0
  filter_redeemableAsOf: BigInt!
}

enum DepositState {
  # DOES NOT EXIST YET
  START

  # FUNDING FLOW
  AWAITING_SIGNER_SETUP
  AWAITING_BTC_FUNDING_PROOF

  # FAILED SETUP
  FAILED_SETUP

  # ACTIVE
  ACTIVE # includes courtesy call
  # REDEMPTION FLOW
  AWAITING_WITHDRAWAL_SIGNATURE
  AWAITING_WITHDRAWAL_PROOF
  REDEEMED

  # SIGNER LIQUIDATION FLOW
  COURTESY_CALL
  FRAUD_LIQUIDATION_IN_PROGRESS
  LIQUIDATION_IN_PROGRESS
  LIQUIDATED
}

type DepositSetup @entity {
  id: ID!
  deposit: Deposit!

  failureReason: SetupFailedReason,
  fundingProofTimerStartedAt: BigInt
}

enum LiquidationCause {
  FRAUD
  UNDERCOLLATERIZED,
  SIGNATURE_TIMEOUT,
  PROOF_TIMEOUT
}

type DepositLiquidation @entity {
  id: ID!
  deposit: Deposit!
  initiateTxhash: Bytes
  courtesyCallTxhash: Bytes
  liquidationInitiated: BigInt # Timestamp of when liquidation starts
  courtesyCallInitiated: BigInt # When the courtesy call is issued
  isLiquidated: Boolean!
  liquidatedAt: BigInt
  liquidationInitiator: Bytes
  cause: LiquidationCause
}

type DepositRedemption @entity {
  id: ID!
  deposit: Deposit!
  redeemerOutputScript: Bytes # The redeemer output script
  requestedFee: BigInt # the finitial fee as requested
  latestRedemptionFee: BigInt # the fee currently required by a redemption transaction
  withdrawalRequestAt: BigInt # the most recent withdrawal request timestamp
  redeemedAt: BigInt
  lastRequestedDigest: Bytes # the digest most recently requested for signing
  outpoint: Bytes
  utxoSize: BigInt
  txid: Bytes
}

"""
An actor using the minting and redeeming facilities.
"""
type User @entity {
  id: ID!
  address: Bytes!

  "The number of deposits the user initiated."
  numDepositsCreated: Int!
  "The number of deposits the user initiated, then did not complete the funding process of. Excludes any deposits which failed due to signer issues."
  numDepositsUnfunded: Int!
  "The number of deposits the user requested to be redeemed."
  numDepositsRedeemed: Int!
  "The number of deposits the user requested to be redeemed, where the deposit was also created by them."
  numOwnDepositsRedeemed: Int!
}

"""
A node operator.

In Staking terms (https://docs.keep.network/random-beacon/staking/), there is an abstract role called the Staker,
representing owner, operator, beneficiary and authorizer. "Stakers are identified by their operator address", and
in our graph, through the Operator entity. Understand that in staking terms, only a single owner can delegate
their tokens to a particular owner, so the tokens staked always come from the samea address.
"""
type Operator @entity {
  id: ID!
  address: Bytes!

  keeps: [BondedECDSAKeep!] @derivedFrom(field: "members")
  bonds: [Bond!]! @derivedFrom(field: "operator")

  locks: [Lock!]! @derivedFrom(field: "operator")

  # The other "staker" roles.
  owner: Bytes
  operator: Bytes
  beneficiary: Bytes
  authorizer: Bytes

  # Statistics
  bonded: BigDecimal!
  unboundAvailable: BigDecimal!
  totalKeepCount: Int!
  activeKeepCount: Int!
  stakedAmount: BigDecimal!

  totalTBTCRewards: BigDecimal!

  "How often this operator was involved in a fault, attributable to them."
  attributableFaultCount: Int!
  "How often this operator was involved in a fault, attributable to them."
  involvedInFaultCount: Int!
  "How often this operator was involved in a fault, either attributable or not."
  totalFaultCount: Int!
}

# can I overtake the withdrawal stakers
# what was the bug they had initially?

"""
A lock on an operator stake.
"""
type Lock @entity {
  id: ID!
  creator: Bytes!
  operator: Operator!
  until: BigInt!
}

enum BondStatus {
  ACTIVE
  RELEASED
  SEIZED
}

type Bond @entity {
  id: ID!
  status: BondStatus!
  referenceID: BigInt!
  bondedAmount: BigDecimal!
  operator: Operator!
  holder: Bytes!
  keep: BondedECDSAKeep!
}

type BondedECDSAKeep @entity {
  id: ID!
  createdAt: BigInt!
  keepAddress: Bytes!
  deposit: Deposit!
  totalBondAmount: BigInt
  publicKey: Bytes
  status: BondedECDSAKeepStatus
  honestThreshold: Int
  members: [Operator]!

  "The nodes which have submitted their pubkey."
  pubkeySubmissions: [Operator]!
}

enum BondedECDSAKeepStatus {
  ACTIVE
  CLOSED
  TERMINATED
}

type GovernanceLogEntry @entity {
  id: ID!
  timestamp: BigInt!
  submitter: Bytes!
  block: BigInt!
  transactionHash: String!
  isRequest: Boolean!
  change: GovernanceChange
}

enum GovernanceChangeType {
  LOT_SIZES,
  SIGNER_FEE_DIVISOR,
  KEEP_FACTORIES,
  COLLATERALIZATION_THRESHOLDS,
  ETH_BTC_PRICE_FEED_ADDITION
}

type GovernanceChange @entity {
  id: ID!
  type: GovernanceChangeType!
  requestedAt: BigInt!
  takesEffectAfter: BigInt!
  requestBlock: BigInt!
  requestTransactionHash: String!
  finalizeBlock: BigInt
  finalizeTransactionHash: String,

  # A copy of the governance type, but all fields are optional. It might be preferable to use interfaces
  # and separate subtypes for each log change kind, but this spams the type list of the graph too much,
  # and we have no ability for any type to be non-root.
  newLotSizes: [BigInt!]
  newSignerFeeDivisor: Int,
  newFactorySelector: Bytes
  newFullyBackedFactory: Bytes
  newKeepStakedFactory: Bytes,
  newPriceFeed: Bytes,
  newInitialCollateralizedPercent: Int,
  newSeverelyUndercollateralizedThresholdPercent: Int,
  newUndercollateralizedThresholdPercent: Int,

  prevLotSizes: [BigInt!]
  prevSignerFeeDivisor: Int,
  prevFactorySelector: Bytes
  prevFullyBackedFactory: Bytes
  prevKeepStakedFactory: Bytes,
  prevInitialCollateralizedPercent: Int,
  prevSeverelyUndercollateralizedThresholdPercent: Int,
  prevUndercollateralizedThresholdPercent: Int,
}


type Governance @entity {
  id: ID!

  newDepositsAllowed: Boolean!

  signerFeeDivisor: Int!,
  pendingSignerFeeDivisorChange: GovernanceChange,

  lotSizes: [BigInt!]!
  pendingLotSizeChange: GovernanceChange

  factorySelector: Bytes!
  fullyBackedFactory: Bytes!
  keepStakedFactory: Bytes!
  pendingFactoriesChange: GovernanceChange

  priceFeeds: [Bytes!]!
  pendingPriceFeedAddition: GovernanceChange,

  initialCollateralizedPercent: Int!,
  severelyUndercollateralizedThresholdPercent: Int!,
  undercollateralizedThresholdPercent: Int!,
  pendingCollateralizationThresholdsChange: GovernanceChange,
}

type StatsRecord @entity {
  id: ID!

  availableToBeBonded: BigDecimal!
  totalBonded: BigDecimal!
  totalBondsSeized: BigDecimal!

  "The total amount of BTC currently deposited, measured from funding proof received to redemption proof received."
  btcUnderDeposit: BigInt!
  "The total amount of BTC currently deposited, measured from funding proof received to redemption requested"
  btcInActiveDeposits: BigInt!
}

"""
Exposes some global system status data. Only a single record with the id "current" is available.
"""
type StatusRecord @entity {
  id: ID!

  "The currently requested RandomBeacon relay entry, if any. Only a single request can exist at a time."
  currentRequestedRelayEntry: RelayEntry
}

type RandomBeaconGroup @entity {
  id: ID!
  pubKey: Bytes!

  createdAt: BigInt!
  members: [Operator!]!
  memberCount: Int!
  rewardPerMember: BigInt!

  relayEntries: [RelayEntry!]! @derivedFrom(field: "group")
}

type RelayEntry @entity {
  id: ID!
  requestedAt: BigInt!
  requestedBy: Bytes!
  group: RandomBeaconGroup!

  requestId: BigInt
  value: BigInt
  generatedAt: BigInt
  rewardPerMember: BigInt
}